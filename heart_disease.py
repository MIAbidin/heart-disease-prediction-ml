# -*- coding: utf-8 -*-
"""Heart_Disease.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18wYlefeISA3iJm89IOpzp7va7xvvLwbg

# Predictive Analytics for Heart Disease - Muhammad Irfan Abidin

Proyek ini bertujuan untuk membangun model analitik prediktif yang dapat mendeteksi risiko penyakit jantung berdasarkan berbagai fitur yang tersedia dalam dataset.

## Data Loading
Data Loading adalah tahap awal dalam proses analisis data untuk memuat dataset ke dalam lingkungan pemrograman

### library
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from imblearn.over_sampling import SMOTE
import numpy as np

"""### import dataset
Dataset diambil dari kaggle yang sudah disimpan di Google Drive, kemudian dimuat ke dalam DataFrame menggunakan Pandas.
"""

heart = pd.read_csv('https://drive.google.com/uc?export=download&id=1yiTBiaD0GlsrBCNf0DTU9__EIImqoZz5')
heart



"""## Exploratory Data Analysis
Tahap ini bertujuan untuk memahami data lebih dalam sebelum melakukan pemodelan. Dengan melakukan beberapa analisis sebagai berikut:

### Deskripsi Variabel
"""

heart.info()

"""

*   Terdapat 8 kolom dengan tipe object
*   Terdapat 8 kolom dengan tipe int64

"""

heart.describe()

"""### Missing Value
Dataset dicek untuk nilai yang hilang. Setelah itu, semua baris dengan nilai kosong dihapus untuk memastikan kualitas data.
"""

heart.isnull().sum()

"""Terdapat missing value untuk kolom Alcohol Intake sebanyak 340 baris, maka harus dihapus"""

heart.dropna(inplace=True)

heart.isnull().sum()



"""### Outliers
Outlier pada fitur numerik diidentifikasi menggunakan boxplot untuk memastikan distribusi data yang normal
"""

numerical_features = [
    'Age', 'Cholesterol', 'Blood Pressure', 'Heart Rate', 'Exercise Hours', 'Stress Level', 'Blood Sugar', 'Heart Disease'
]


categorical_features = [
    'Gender', 'Smoking', 'Alcohol Intake', 'Family History', 'Diabetes', 'Obesity', 'Exercise Induced Angina', 'Chest Pain Type'
]

plt.figure(figsize=(15, 10))
for i, feature in enumerate(numerical_features, 1):
    plt.subplot(3, 3, i)
    sns.boxplot(data=heart, y=feature)
    plt.title(f"Boxplot of {feature}")
plt.tight_layout()
plt.show()

"""Berdasarkan hasil visualisasi diatas, data terlihat normal tanpa adanya outlier

### Univariate Analysis
Analisis distribusi dilakukan untuk setiap fitur, baik numerik maupun kategorikal. Visualisasi seperti histogram dan bar chart digunakan untuk membantu memahami distribusi data.

#### Categorical Features
"""

feature = categorical_features[0]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

"""Berdasarkan hasil diatas jumlah male lebih banyak dibandingkan female"""

feature = categorical_features[1]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

"""Berdasarkan hasil diatas kategori never, current, dan former tampak memiliki jumlah yang relatif seimbang, dengan sedikit perbedaan"""

feature = categorical_features[2]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

"""Berdasarakn hasil diatas kategori Heavy lebih banyak dibandingkan moderate"""

feature = categorical_features[3]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

"""Berdasarkan hasil diatas kedua kategori memiliki jumlah yang seimbang"""

feature = categorical_features[4]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

"""Berdasrkan hasil diatas kedua kategori memiliki jumlah yang hampir seimbang"""

feature = categorical_features[5]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

feature = categorical_features[6]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

feature = categorical_features[7]
count = heart[feature].value_counts()
percent = 100 * heart[feature].value_counts(normalize=True)
result = pd.DataFrame({'jumlah sampel': count, 'persentase': percent.round(1)})
print(result)
count.plot(kind='bar', title=feature)
plt.show()

"""Berdasarkan hasil diatas urutan nyeri dada yang paling banyak adalah Non-anginal pain, Asymptomatic, Typical Angina, Aypical Angina.

#### Numerical Features
"""

heart.hist(bins=50, figsize=(20,15))
plt.show()

"""- Analisis univariate menunjukkan bahwa fitur seperti **Age**, **Cholesterol**, dan **Blood Pressure** berpotensi memiliki hubungan dengan penyakit jantung.
- Distribusi target memperlihatkan ketidakseimbangan data, di mana lebih banyak pasien yang tidak memiliki penyakit jantung (nilai `0`). Oleh karena itu, diperlukan teknik penyeimbangan data seperti oversampling atau undersampling untuk meningkatkan akurasi model pada kelas minoritas (nilai `1`).

### Multivariate Analysis

#### Categorical Features
"""

cat_features = heart.select_dtypes(include='object').columns.to_list()

for col in cat_features:
  sns.catplot(x=col, y="Heart Disease", kind="bar", dodge=False, height = 4, aspect = 3,  data=heart, palette="Set3")
  plt.title("Rata-rata 'Heart Disease' Relatif terhadap - {}".format(col))

"""- Beberapa fitur kategorikal seperti **Gender**, **Alcohol Intake**, **Family History**, **Diabetes**, **Obesity**, dan **Exercise Induced Angina** menunjukkan pengaruh yang relatif rendah terhadap penyakit jantung, karena distribusi risiko antar kategori cenderung serupa.
- **Smoking** memiliki pengaruh sedang terhadap risiko penyakit jantung, di mana perokok aktif lebih rentan terkena penyakit jantung.
- **Chest Pain Type** merupakan fitur yang paling signifikan, dengan variasi risiko yang jelas antar kategori nyeri dada terhadap penyakit jantung.

#### Numerical Features
"""

sns.pairplot(heart, diag_kind = 'kde')

plt.figure(figsize=(10, 8))
correlation_matrix = heart[numerical_features].corr().round(2)
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""*   Fitur **Age** memiliki skor korelasi yang cukup tinggi (0.65) dengan fitur target **Heart Disease**. Ini menunjukkan bahwa semakin tua seseorang, semakin tinggi kemungkinan menderita penyakit jantung.

*   Fitur **Cholesterol** juga memiliki korelasi positif moderat (0.37) dengan Heart Disease, sehingga kolesterol dapat menjadi faktor penting dalam memprediksi penyakit jantung.

*   Sebaliknya, fitur seperti **Blood Pressure**, **Exercise Hours**, dan **Stress Level** memiliki korelasi yang sangat kecil terhadap **Heart Disease** (mendekati 0). Dengan demikian, fitur-fitur tersebut mungkin kurang berkontribusi signifikan dalam model prediksi dan dapat dipertimbangkan untuk di-drop.

## Data Preparation
Pada tahapan ini  data dipersiapkan untuk digunakan dalam pemodelan Machine Learning. Tahap ini mencakup pembersihan data, transformasi data, encoding fitur kategorikal, penanganan ketidakseimbangan data, dan standarisasi fitur numerik.

### Menghapus Fitur
Beberapa fitur dengan korelasi rendah terhadap target dihapus untuk mengurangi kompleksitas model.
"""

low_correlation_features = ['Exercise Hours', 'Stress Level', 'Blood Sugar']
heart.drop(columns=low_correlation_features, inplace=True)

heart.info()



"""### Encoding Fitur Kategorikal
Fitur kategorikal diubah menjadi format numerik menggunakan teknik one-hot encoding.
"""

numerical_features = ['Age', 'Cholesterol', 'Blood Pressure', 'Heart Rate']

heart = pd.get_dummies(heart, columns=categorical_features, drop_first=True, dtype='int')
heart

"""### Split Data ke dalam Set Pelatihan dan Pengujian
Dataset dipecah menjadi data latih (80%) dan data uji (20%) untuk memastikan evaluasi model yang valid.


"""

X = heart.drop("Heart Disease", axis=1)
y = heart["Heart Disease"]

# Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)
print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""### Imbalance
Menggunakan teknik SMOTE untuk menyeimbangkan distribusi kelas, sehingga model lebih adil dalam memprediksi kelas minoritas.
"""

smote = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

# Distribusi sebelum SMOTE
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
y_train.value_counts(sort=False).plot(kind='bar', color=['blue', 'orange'], alpha=0.7)
plt.title("Distribusi Kelas Sebelum SMOTE")
plt.xlabel("Kelas")
plt.ylabel("Jumlah Sampel")
plt.grid(axis='y', linestyle='--', linewidth=0.5, alpha=0.7)

# Distribusi setelah SMOTE
plt.subplot(1, 2, 2)
pd.Series(y_train_resampled).value_counts(sort=False).plot(kind='bar', color=['blue', 'orange'], alpha=0.7)
plt.title("Distribusi Kelas Setelah SMOTE")
plt.xlabel("Kelas")
plt.ylabel("Jumlah Sampel")
plt.grid(axis='y', linestyle='--', linewidth=0.5, alpha=0.7)

plt.tight_layout()
plt.show()



"""### Standarisasi
Fitur numerik distandarisasi agar berada pada skala yang sama, meningkatkan performa model tertentu seperti Logistic Regression.
"""

scaler = StandardScaler()
X_train_resampled[numerical_features] = scaler.fit_transform(X_train_resampled[numerical_features])
X_test[numerical_features] = scaler.transform(X_test[numerical_features])

X_train_resampled[numerical_features].head()

X_train_resampled[numerical_features].describe().round(4)

"""## Modelling
Beberapa algoritma machine learning digunakan untuk membangun model prediktif:

1. K-Nearest Neighbors (KNN)
2. Logistic Regression
3. Random Forest
4. AdaBoost
5. Gradient Boosting

"""

models = {
    'KNN': KNeighborsClassifier(n_neighbors=10),
    'LogisticRegression': LogisticRegression(max_iter=1000, random_state=55),
    'RandomForest': RandomForestClassifier(n_estimators=50, max_depth=16, random_state=55),
    'Boosting': AdaBoostClassifier(learning_rate=0.05, random_state=55),
    'GradientBoosting': GradientBoostingClassifier(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=55),
}

"""## Evaluation
Model dievaluasi berdasarkan metrik-metrik berikut:

- Akurasi: Persentase prediksi yang benar.
- Precision: Proporsi prediksi positif yang benar.
- Recall: Kemampuan model mendeteksi kelas positif.
- F1 Score: Harmoni antara precision dan recall.
"""

results = pd.DataFrame(columns=['Akurasi Train', 'Akurasi Test', 'Precision', 'Recall', 'F1 Score'])

for model_name, model in models.items():
    model.fit(X_train_resampled, y_train_resampled)

    y_train_pred = model.predict(X_train_resampled)
    y_test_pred = model.predict(X_test)

    train_accuracy = round(accuracy_score(y_train_resampled, y_train_pred), 3)
    test_accuracy = round(accuracy_score(y_test, y_test_pred), 3)
    precision = round(precision_score(y_test, y_test_pred), 3)
    recall = round(recall_score(y_test, y_test_pred), 3)
    f1 = round(f1_score(y_test, y_test_pred), 3)

    results.loc[model_name] = [train_accuracy, test_accuracy, precision, recall, f1]

print("\nHasil Evaluasi Model:")
print(results)

results.plot(kind='bar', figsize=(10, 6), colormap='viridis')
plt.title("Perbandingan Performa Model")
plt.ylabel("Skor")
plt.xlabel("Model")
plt.xticks(rotation=45)
plt.legend(loc='lower right')
plt.grid(axis='y', linestyle='--', linewidth=0.7, alpha=0.7)
plt.tight_layout()
plt.show()

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

for model_name, model in models.items():
    y_test_pred = model.predict(X_test)
    cm = confusion_matrix(y_test, y_test_pred)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=['No Disease', 'Disease'])
    disp.plot(cmap='Blues')
    plt.title(f"Confusion Matrix - {model_name}")
    plt.show()

"""1. **Logistic Regression**:
   - Akurasi pada test set mencapai 87%.
   - Precision dan recall menunjukkan performa yang seimbang, namun hasilnya lebih rendah dibandingkan model lain karena Logistic Regression cenderung kurang optimal untuk data yang tidak linier.

2. **K-Nearest Neighbors (KNN)**:
   - Akurasi pada test set mencapai 92%.
   - Precision yang lebih rendah (**78%**) menunjukkan model ini cenderung menghasilkan lebih banyak prediksi positif yang salah. Recall cukup tinggi (**89%**), yang berarti model ini cukup sensitif dalam mendeteksi kasus positif.

3. **Random Forest, AdaBoost, Gradient Boosting**:
   - Semua metrik (akurasi, precision, recall, F1 Score) mencapai 100%.
   - Model ini memberikan performa sempurna, baik pada training set maupun test set, menunjukkan kemampuan yang sangat baik dalam menangani data yang kompleks.

### Kesimpulan

**Gradient Boosting** dipilih sebagai model terbaik karena memberikan hasil evaluasi sempurna. Selain akurasi tinggi, model ini lebih fleksibel dalam menangani data yang kompleks.. Evaluasi menggunakan precision dan recall sangat relevan dalam konteks medis, di mana kesalahan prediksi dapat memiliki konsekuensi serius. Gradient Boosting memberikan hasil terbaik untuk kebutuhan ini dengan precision dan recall yang sempurna.

Dengan menggunakan kombinasi keempat metrik ini, performa model dapat dinilai lebih komprehensif sesuai dengan kebutuhan proyek, khususnya dalam kasus medis yang membutuhkan deteksi risiko kesehatan secara akurat.
"""